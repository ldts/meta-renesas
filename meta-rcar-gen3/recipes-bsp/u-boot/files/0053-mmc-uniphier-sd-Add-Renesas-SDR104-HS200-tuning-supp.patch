From 81b01b443bb963db4668c8a9d18dcbe07305e355 Mon Sep 17 00:00:00 2001
From: Marek Vasut <marek.vasut+renesas@gmail.com>
Date: Sat, 23 Sep 2017 13:30:30 +0200
Subject: [PATCH 53/56] mmc: uniphier-sd: Add Renesas SDR104/HS200 tuning
 support

Add code for PHY tuning required for SDR104/HS200 support on Renesas RCar.

Signed-off-by: Marek Vasut <marek.vasut+renesas@gmail.com>
Cc: Jaehoon Chung <jh80.chung@samsung.com>
Cc: Masahiro Yamada <yamada.masahiro@socionext.com>
---
 drivers/mmc/uniphier-sd.c | 290 ++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 290 insertions(+)

diff --git a/drivers/mmc/uniphier-sd.c b/drivers/mmc/uniphier-sd.c
index f0cf14c264..3e0d61268e 100644
--- a/drivers/mmc/uniphier-sd.c
+++ b/drivers/mmc/uniphier-sd.c
@@ -143,6 +143,10 @@ struct uniphier_sd_priv {
 #endif
 };
 
+#if CONFIG_IS_ENABLED(MMC_HS200_SUPPORT)
+static void uniphier_sd_reset_tuning(struct uniphier_sd_priv *priv);
+#endif
+
 static u64 uniphier_sd_readq(struct uniphier_sd_priv *priv, unsigned int reg)
 {
 	if (priv->caps & UNIPHIER_SD_CAP_64BIT)
@@ -596,6 +600,7 @@ static int uniphier_sd_set_bus_width(struct uniphier_sd_priv *priv,
 	u32 val, tmp;
 
 	switch (mmc->bus_width) {
+	case 0:
 	case 1:
 		val = UNIPHIER_SD_OPTION_WIDTH_1;
 		break;
@@ -694,6 +699,7 @@ static void uniphier_sd_set_pins(struct udevice *dev)
 			regulator_set_value(priv->vqmmc_dev, 1800000);
 		else
 			regulator_set_value(priv->vqmmc_dev, 3300000);
+		regulator_set_enable(priv->vqmmc_dev, true);
 	}
 
 	if (mmc->signal_voltage == MMC_SIGNAL_VOLTAGE_180)
@@ -718,6 +724,11 @@ static int uniphier_sd_set_ios(struct udevice *dev)
 	uniphier_sd_set_clk_rate(priv, mmc);
 	uniphier_sd_set_pins(dev);
 
+#if CONFIG_IS_ENABLED(MMC_HS200_SUPPORT)
+	if (priv->caps & UNIPHIER_SD_CAP_RCAR_UHS)
+		uniphier_sd_reset_tuning(priv);
+#endif
+
 	return 0;
 }
 
@@ -732,10 +743,284 @@ static int uniphier_sd_get_cd(struct udevice *dev)
 		  UNIPHIER_SD_INFO1_CD);
 }
 
+/*
+ * Renesas RCar SDR104 / HS200
+ */
+#if CONFIG_IS_ENABLED(MMC_HS200_SUPPORT)
+
+/* SCC registers */
+#define SH_MOBILE_SDHI_SCC_DTCNTL			0x800
+#define   SH_MOBILE_SDHI_SCC_DTCNTL_TAPEN		BIT(0)
+#define   SH_MOBILE_SDHI_SCC_DTCNTL_TAPNUM_SHIFT	16
+#define   SH_MOBILE_SDHI_SCC_DTCNTL_TAPNUM_MASK		0xff
+#define SH_MOBILE_SDHI_SCC_TAPSET			0x804
+#define SH_MOBILE_SDHI_SCC_DT2FF			0x808
+#define SH_MOBILE_SDHI_SCC_CKSEL			0x80c
+#define   SH_MOBILE_SDHI_SCC_CKSEL_DTSEL		BIT(0)
+#define SH_MOBILE_SDHI_SCC_RVSCNTL			0x810
+#define   SH_MOBILE_SDHI_SCC_RVSCNTL_RVSEN		BIT(0)
+#define SH_MOBILE_SDHI_SCC_RVSREQ			0x814
+#define   SH_MOBILE_SDHI_SCC_RVSREQ_RVSERR		BIT(2)
+#define SH_MOBILE_SDHI_SCC_SMPCMP			0x818
+#define SH_MOBILE_SDHI_SCC_TMPPORT2			0x81c
+
+#define SH_MOBILE_SDHI_MAX_TAP 3
+
+static unsigned int uniphier_sd_init_tuning(struct uniphier_sd_priv *priv)
+{
+	u32 reg;
+
+	/* Initialize SCC */
+	uniphier_sd_writel(priv, 0, UNIPHIER_SD_INFO1);
+
+	reg = uniphier_sd_readl(priv, UNIPHIER_SD_CLKCTL);
+	reg &= ~UNIPHIER_SD_CLKCTL_SCLKEN;
+	uniphier_sd_writel(priv, reg, UNIPHIER_SD_CLKCTL);
+
+	/* Set sampling clock selection range */
+	uniphier_sd_writel(priv, 0x8 << SH_MOBILE_SDHI_SCC_DTCNTL_TAPNUM_SHIFT,
+			   SH_MOBILE_SDHI_SCC_DTCNTL);
+
+	reg = uniphier_sd_readl(priv, SH_MOBILE_SDHI_SCC_DTCNTL);
+	reg |= SH_MOBILE_SDHI_SCC_DTCNTL_TAPEN;
+	uniphier_sd_writel(priv, reg, SH_MOBILE_SDHI_SCC_DTCNTL);
+
+	reg = uniphier_sd_readl(priv, SH_MOBILE_SDHI_SCC_CKSEL);
+	reg |= SH_MOBILE_SDHI_SCC_CKSEL_DTSEL;
+	uniphier_sd_writel(priv, reg, SH_MOBILE_SDHI_SCC_CKSEL);
+
+	reg = uniphier_sd_readl(priv, SH_MOBILE_SDHI_SCC_RVSCNTL);
+	reg &= ~SH_MOBILE_SDHI_SCC_RVSCNTL_RVSEN;
+	uniphier_sd_writel(priv, reg, SH_MOBILE_SDHI_SCC_RVSCNTL);
+
+	uniphier_sd_writel(priv, 0x300 /* scc_tappos */,
+			   SH_MOBILE_SDHI_SCC_DT2FF);
+
+	reg = uniphier_sd_readl(priv, UNIPHIER_SD_CLKCTL);
+	reg |= UNIPHIER_SD_CLKCTL_SCLKEN;
+	uniphier_sd_writel(priv, reg, UNIPHIER_SD_CLKCTL);
+
+	/* Read TAPNUM */
+	return (uniphier_sd_readl(priv, SH_MOBILE_SDHI_SCC_DTCNTL) >>
+		SH_MOBILE_SDHI_SCC_DTCNTL_TAPNUM_SHIFT) &
+		SH_MOBILE_SDHI_SCC_DTCNTL_TAPNUM_MASK;
+}
+
+static void uniphier_sd_reset_tuning(struct uniphier_sd_priv *priv)
+{
+	u32 reg;
+
+	/* Reset SCC */
+	reg = uniphier_sd_readl(priv, UNIPHIER_SD_CLKCTL);
+	reg &= ~UNIPHIER_SD_CLKCTL_SCLKEN;
+	uniphier_sd_writel(priv, reg, UNIPHIER_SD_CLKCTL);
+
+	reg = uniphier_sd_readl(priv, SH_MOBILE_SDHI_SCC_CKSEL);
+	reg &= ~SH_MOBILE_SDHI_SCC_CKSEL_DTSEL;
+	uniphier_sd_writel(priv, reg, SH_MOBILE_SDHI_SCC_CKSEL);
+
+	reg = uniphier_sd_readl(priv, UNIPHIER_SD_CLKCTL);
+	reg |= UNIPHIER_SD_CLKCTL_SCLKEN;
+	uniphier_sd_writel(priv, reg, UNIPHIER_SD_CLKCTL);
+
+	reg = uniphier_sd_readl(priv, SH_MOBILE_SDHI_SCC_RVSCNTL);
+	reg &= ~SH_MOBILE_SDHI_SCC_RVSCNTL_RVSEN;
+	uniphier_sd_writel(priv, reg, SH_MOBILE_SDHI_SCC_RVSCNTL);
+
+	reg = uniphier_sd_readl(priv, SH_MOBILE_SDHI_SCC_RVSCNTL);
+	reg &= ~SH_MOBILE_SDHI_SCC_RVSCNTL_RVSEN;
+	uniphier_sd_writel(priv, reg, SH_MOBILE_SDHI_SCC_RVSCNTL);
+}
+
+static void uniphier_sd_prepare_tuning(struct uniphier_sd_priv *priv,
+				       unsigned long tap)
+{
+	/* Set sampling clock position */
+	uniphier_sd_writel(priv, tap, SH_MOBILE_SDHI_SCC_TAPSET);
+}
+
+static unsigned int sh_mobile_sdhi_compare_scc_data(struct uniphier_sd_priv *priv)
+{
+	/* Get comparison of sampling data */
+	return uniphier_sd_readl(priv, SH_MOBILE_SDHI_SCC_SMPCMP);
+}
+
+static int uniphier_sd_select_tuning(struct uniphier_sd_priv *priv,
+				     unsigned int tap_num, unsigned int taps,
+				     unsigned int smpcmp)
+{
+	unsigned long tap_cnt;  /* counter of tuning success */
+	unsigned long tap_set;  /* tap position */
+	unsigned long tap_start;/* start position of tuning success */
+	unsigned long tap_end;  /* end position of tuning success */
+	unsigned long ntap;     /* temporary counter of tuning success */
+	unsigned long match_cnt;/* counter of matching data */
+	unsigned long i;
+	bool select = false;
+	u32 reg;
+
+	/* Clear SCC_RVSREQ */
+	uniphier_sd_writel(priv, 0, SH_MOBILE_SDHI_SCC_RVSREQ);
+
+	/* Merge the results */
+	for (i = 0; i < tap_num * 2; i++) {
+		if (!(taps & BIT(i))) {
+			taps &= ~BIT(i % tap_num);
+			taps &= ~BIT((i % tap_num) + tap_num);
+		}
+		if (!(smpcmp & BIT(i))) {
+			smpcmp &= ~BIT(i % tap_num);
+			smpcmp &= ~BIT((i % tap_num) + tap_num);
+		}
+	}
+
+	/*
+	 * Find the longest consecutive run of successful probes.  If that
+	 * is more than SH_MOBILE_SDHI_MAX_TAP probes long then use the
+	 * center index as the tap.
+	 */
+	tap_cnt = 0;
+	ntap = 0;
+	tap_start = 0;
+	tap_end = 0;
+	for (i = 0; i < tap_num * 2; i++) {
+		if (taps & BIT(i))
+			ntap++;
+		else {
+			if (ntap > tap_cnt) {
+				tap_start = i - ntap;
+				tap_end = i - 1;
+				tap_cnt = ntap;
+			}
+			ntap = 0;
+		}
+	}
+
+	if (ntap > tap_cnt) {
+		tap_start = i - ntap;
+		tap_end = i - 1;
+		tap_cnt = ntap;
+	}
+
+	/*
+	 * If all of the TAP is OK, the sampling clock position is selected by
+	 * identifying the change point of data.
+	 */
+	if (tap_cnt == tap_num * 2) {
+		match_cnt = 0;
+		ntap = 0;
+		tap_start = 0;
+		tap_end = 0;
+		for (i = 0; i < tap_num * 2; i++) {
+			if (smpcmp & BIT(i))
+				ntap++;
+			else {
+				if (ntap > match_cnt) {
+					tap_start = i - ntap;
+					tap_end = i - 1;
+					match_cnt = ntap;
+				}
+				ntap = 0;
+			}
+		}
+		if (ntap > match_cnt) {
+			tap_start = i - ntap;
+			tap_end = i - 1;
+			match_cnt = ntap;
+		}
+		if (match_cnt)
+			select = true;
+	} else if (tap_cnt >= SH_MOBILE_SDHI_MAX_TAP)
+		select = true;
+
+	if (select)
+		tap_set = ((tap_start + tap_end) / 2) % tap_num;
+	else
+		return -EIO;
+
+	/* Set SCC */
+	uniphier_sd_writel(priv, tap_set, SH_MOBILE_SDHI_SCC_TAPSET);
+
+	/* Enable auto re-tuning */
+	reg = uniphier_sd_readl(priv, SH_MOBILE_SDHI_SCC_RVSCNTL);
+	reg |= SH_MOBILE_SDHI_SCC_RVSCNTL_RVSEN;
+	uniphier_sd_writel(priv, reg, SH_MOBILE_SDHI_SCC_RVSCNTL);
+
+	return 0;
+}
+
+static int uniphier_sd_execute_tuning(struct udevice *dev, uint opcode)
+{
+	struct uniphier_sd_priv *priv = dev_get_priv(dev);
+	struct mmc_uclass_priv *upriv = dev_get_uclass_priv(dev);
+	struct mmc *mmc = upriv->mmc;
+	unsigned int tap_num;
+	unsigned int taps = 0, smpcmp = 0;
+	int i, ret = 0;
+	u32 caps;
+
+	/* Only supported on Renesas RCar */
+	if (!(priv->caps & UNIPHIER_SD_CAP_RCAR_UHS))
+		return -EINVAL;
+
+	/* clock tuning is not needed for upto 52MHz */
+	if (!((mmc->selected_mode == MMC_HS_200) ||
+	      (mmc->selected_mode == UHS_SDR104) ||
+	      (mmc->selected_mode == UHS_SDR50)))
+		return 0;
+
+	tap_num = uniphier_sd_init_tuning(priv);
+	if (!tap_num)
+		/* Tuning is not supported */
+		goto out;
+
+	if (tap_num * 2 >= sizeof(taps) * 8) {
+		dev_err(dev,
+			"Too many taps, skipping tuning. Please consider updating size of taps field of tmio_mmc_host\n");
+		goto out;
+	}
+
+	/* Issue CMD19 twice for each tap */
+	for (i = 0; i < 2 * tap_num; i++) {
+		uniphier_sd_prepare_tuning(priv, i % tap_num);
+
+		/* Force PIO for the tuning */
+		caps = priv->caps;
+		priv->caps &= ~UNIPHIER_SD_CAP_DMA_INTERNAL;
+
+		ret = mmc_send_tuning(mmc, opcode, NULL);
+
+		priv->caps = caps;
+
+		if (ret == 0)
+			taps |= BIT(i);
+
+		ret = sh_mobile_sdhi_compare_scc_data(priv);
+		if (ret == 0)
+			smpcmp |= BIT(i);
+
+		mdelay(1);
+	}
+
+	ret = uniphier_sd_select_tuning(priv, tap_num, taps, smpcmp);
+
+out:
+	if (ret < 0) {
+		dev_warn(dev, "Tuning procedure failed\n");
+		uniphier_sd_reset_tuning(priv);
+	}
+
+	return ret;
+}
+#endif
+
 static const struct dm_mmc_ops uniphier_sd_ops = {
 	.send_cmd = uniphier_sd_send_cmd,
 	.set_ios = uniphier_sd_set_ios,
 	.get_cd = uniphier_sd_get_cd,
+#if CONFIG_IS_ENABLED(MMC_HS200_SUPPORT)
+	.execute_tuning = uniphier_sd_execute_tuning,
+#endif
 };
 
 static void uniphier_sd_host_init(struct uniphier_sd_priv *priv)
@@ -853,6 +1138,11 @@ static int uniphier_sd_probe(struct udevice *dev)
 
 	upriv->mmc = &plat->mmc;
 
+#if CONFIG_IS_ENABLED(MMC_HS200_SUPPORT)
+	if (priv->caps & UNIPHIER_SD_CAP_RCAR_UHS)
+		uniphier_sd_reset_tuning(priv);
+#endif
+
 	return 0;
 }
 
-- 
2.15.1

